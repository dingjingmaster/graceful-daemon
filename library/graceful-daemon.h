/* graceful-daemon.h generated by valac 0.52.3, the Vala compiler, do not modify */

#ifndef __GRACEFUL_DAEMON_H__
#define __GRACEFUL_DAEMON_H__

#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <gio/gio.h>
#include <float.h>
#include <math.h>
#include <gee.h>
#include <gtk/gtk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <json-glib/json-glib.h>
#include <cairo-gobject.h>

G_BEGIN_DECLS

#define TYPE_APP_LOCK (app_lock_get_type ())
#define APP_LOCK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APP_LOCK, AppLock))
#define APP_LOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APP_LOCK, AppLockClass))
#define IS_APP_LOCK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APP_LOCK))
#define IS_APP_LOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APP_LOCK))
#define APP_LOCK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APP_LOCK, AppLockClass))

typedef struct _AppLock AppLock;
typedef struct _AppLockClass AppLockClass;
typedef struct _AppLockPrivate AppLockPrivate;

#define TYPE_ASYNC_TASK (async_task_get_type ())
#define ASYNC_TASK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ASYNC_TASK, AsyncTask))
#define ASYNC_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ASYNC_TASK, AsyncTaskClass))
#define IS_ASYNC_TASK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ASYNC_TASK))
#define IS_ASYNC_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ASYNC_TASK))
#define ASYNC_TASK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ASYNC_TASK, AsyncTaskClass))

typedef struct _AsyncTask AsyncTask;
typedef struct _AsyncTaskClass AsyncTaskClass;
typedef struct _AsyncTaskPrivate AsyncTaskPrivate;
typedef enum  {
	APP_STATUS_NOT_STARTED,
	APP_STATUS_RUNNING,
	APP_STATUS_PAUSED,
	APP_STATUS_FINISHED,
	APP_STATUS_CANCELLED,
	APP_STATUS_PASSWORD_REQUIRED
} AppStatus;

#define TYPE_APP_STATUS (app_status_get_type ())

#define TYPE_CRON_TAB (cron_tab_get_type ())
#define CRON_TAB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CRON_TAB, CronTab))
#define CRON_TAB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CRON_TAB, CronTabClass))
#define IS_CRON_TAB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CRON_TAB))
#define IS_CRON_TAB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CRON_TAB))
#define CRON_TAB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CRON_TAB, CronTabClass))

typedef struct _CronTab CronTab;
typedef struct _CronTabClass CronTabClass;
typedef struct _CronTabPrivate CronTabPrivate;

#define TYPE_CRYPT_TAB_ENTRY (crypt_tab_entry_get_type ())
#define CRYPT_TAB_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CRYPT_TAB_ENTRY, CryptTabEntry))
#define CRYPT_TAB_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CRYPT_TAB_ENTRY, CryptTabEntryClass))
#define IS_CRYPT_TAB_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CRYPT_TAB_ENTRY))
#define IS_CRYPT_TAB_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CRYPT_TAB_ENTRY))
#define CRYPT_TAB_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CRYPT_TAB_ENTRY, CryptTabEntryClass))

typedef struct _CryptTabEntry CryptTabEntry;
typedef struct _CryptTabEntryClass CryptTabEntryClass;
typedef struct _CryptTabEntryPrivate CryptTabEntryPrivate;

#define TYPE_DELETE_FILE_TASK (delete_file_task_get_type ())
#define DELETE_FILE_TASK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DELETE_FILE_TASK, DeleteFileTask))
#define DELETE_FILE_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DELETE_FILE_TASK, DeleteFileTaskClass))
#define IS_DELETE_FILE_TASK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DELETE_FILE_TASK))
#define IS_DELETE_FILE_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DELETE_FILE_TASK))
#define DELETE_FILE_TASK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DELETE_FILE_TASK, DeleteFileTaskClass))

typedef struct _DeleteFileTask DeleteFileTask;
typedef struct _DeleteFileTaskClass DeleteFileTaskClass;
typedef struct _DeleteFileTaskPrivate DeleteFileTaskPrivate;

#define TYPE_DEVICE (device_get_type ())
#define DEVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DEVICE, Device))
#define DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DEVICE, DeviceClass))
#define IS_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DEVICE))
#define IS_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DEVICE))
#define DEVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DEVICE, DeviceClass))

typedef struct _Device Device;
typedef struct _DeviceClass DeviceClass;
typedef struct _DevicePrivate DevicePrivate;

#define TYPE_MOUNT_ENTRY (mount_entry_get_type ())
#define MOUNT_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MOUNT_ENTRY, MountEntry))
#define MOUNT_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MOUNT_ENTRY, MountEntryClass))
#define IS_MOUNT_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MOUNT_ENTRY))
#define IS_MOUNT_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MOUNT_ENTRY))
#define MOUNT_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MOUNT_ENTRY, MountEntryClass))

typedef struct _MountEntry MountEntry;
typedef struct _MountEntryClass MountEntryClass;

#define TYPE_FILE_ITEM (file_item_get_type ())
#define FILE_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FILE_ITEM, FileItem))
#define FILE_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FILE_ITEM, FileItemClass))
#define IS_FILE_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FILE_ITEM))
#define IS_FILE_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FILE_ITEM))
#define FILE_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FILE_ITEM, FileItemClass))

typedef struct _FileItem FileItem;
typedef struct _FileItemClass FileItemClass;
typedef struct _FileItemPrivate FileItemPrivate;

#define TYPE_FS_TAB_ENTRY (fs_tab_entry_get_type ())
#define FS_TAB_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FS_TAB_ENTRY, FsTabEntry))
#define FS_TAB_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FS_TAB_ENTRY, FsTabEntryClass))
#define IS_FS_TAB_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FS_TAB_ENTRY))
#define IS_FS_TAB_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FS_TAB_ENTRY))
#define FS_TAB_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FS_TAB_ENTRY, FsTabEntryClass))

typedef struct _FsTabEntry FsTabEntry;
typedef struct _FsTabEntryClass FsTabEntryClass;
typedef struct _FsTabEntryPrivate FsTabEntryPrivate;

#define GRACEFUL_TYPE_DBUS_DAEMON (graceful_dbus_daemon_get_type ())
#define GRACEFUL_DBUS_DAEMON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRACEFUL_TYPE_DBUS_DAEMON, GracefulDBusDaemon))
#define GRACEFUL_DBUS_DAEMON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GRACEFUL_TYPE_DBUS_DAEMON, GracefulDBusDaemonClass))
#define GRACEFUL_IS_DBUS_DAEMON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRACEFUL_TYPE_DBUS_DAEMON))
#define GRACEFUL_IS_DBUS_DAEMON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GRACEFUL_TYPE_DBUS_DAEMON))
#define GRACEFUL_DBUS_DAEMON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GRACEFUL_TYPE_DBUS_DAEMON, GracefulDBusDaemonClass))

typedef struct _GracefulDBusDaemon GracefulDBusDaemon;
typedef struct _GracefulDBusDaemonClass GracefulDBusDaemonClass;
typedef struct _GracefulDBusDaemonPrivate GracefulDBusDaemonPrivate;

#define GRACEFUL_TYPE_PLUGIN_INTERFACE (graceful_plugin_interface_get_type ())
#define GRACEFUL_PLUGIN_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRACEFUL_TYPE_PLUGIN_INTERFACE, GracefulPluginInterface))
#define GRACEFUL_IS_PLUGIN_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRACEFUL_TYPE_PLUGIN_INTERFACE))
#define GRACEFUL_PLUGIN_INTERFACE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GRACEFUL_TYPE_PLUGIN_INTERFACE, GracefulPluginInterfaceIface))

typedef struct _GracefulPluginInterface GracefulPluginInterface;
typedef struct _GracefulPluginInterfaceIface GracefulPluginInterfaceIface;

#define GRACEFUL_TYPE_PLUGIN_MANAGER (graceful_plugin_manager_get_type ())
#define GRACEFUL_PLUGIN_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRACEFUL_TYPE_PLUGIN_MANAGER, GracefulPluginManager))
#define GRACEFUL_PLUGIN_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GRACEFUL_TYPE_PLUGIN_MANAGER, GracefulPluginManagerClass))
#define GRACEFUL_IS_PLUGIN_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRACEFUL_TYPE_PLUGIN_MANAGER))
#define GRACEFUL_IS_PLUGIN_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GRACEFUL_TYPE_PLUGIN_MANAGER))
#define GRACEFUL_PLUGIN_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GRACEFUL_TYPE_PLUGIN_MANAGER, GracefulPluginManagerClass))

typedef struct _GracefulPluginManager GracefulPluginManager;
typedef struct _GracefulPluginManagerClass GracefulPluginManagerClass;
typedef struct _GracefulPluginManagerPrivate GracefulPluginManagerPrivate;

#define TYPE_ICON_MANAGER (icon_manager_get_type ())
#define ICON_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ICON_MANAGER, IconManager))
#define ICON_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ICON_MANAGER, IconManagerClass))
#define IS_ICON_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ICON_MANAGER))
#define IS_ICON_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ICON_MANAGER))
#define ICON_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ICON_MANAGER, IconManagerClass))

typedef struct _IconManager IconManager;
typedef struct _IconManagerClass IconManagerClass;
typedef struct _IconManagerPrivate IconManagerPrivate;

#define TYPE_LINUX_DISTRO (linux_distro_get_type ())
#define LINUX_DISTRO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LINUX_DISTRO, LinuxDistro))
#define LINUX_DISTRO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LINUX_DISTRO, LinuxDistroClass))
#define IS_LINUX_DISTRO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LINUX_DISTRO))
#define IS_LINUX_DISTRO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LINUX_DISTRO))
#define LINUX_DISTRO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LINUX_DISTRO, LinuxDistroClass))

typedef struct _LinuxDistro LinuxDistro;
typedef struct _LinuxDistroClass LinuxDistroClass;
typedef struct _LinuxDistroPrivate LinuxDistroPrivate;
typedef struct _MountEntryPrivate MountEntryPrivate;

#define TYPE_OSD_NOTIFY (osd_notify_get_type ())
#define OSD_NOTIFY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OSD_NOTIFY, OSDNotify))
#define OSD_NOTIFY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OSD_NOTIFY, OSDNotifyClass))
#define IS_OSD_NOTIFY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OSD_NOTIFY))
#define IS_OSD_NOTIFY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OSD_NOTIFY))
#define OSD_NOTIFY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OSD_NOTIFY, OSDNotifyClass))

typedef struct _OSDNotify OSDNotify;
typedef struct _OSDNotifyClass OSDNotifyClass;
typedef struct _OSDNotifyPrivate OSDNotifyPrivate;

#define TYPE_RSYNC_TASK (rsync_task_get_type ())
#define RSYNC_TASK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RSYNC_TASK, RsyncTask))
#define RSYNC_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RSYNC_TASK, RsyncTaskClass))
#define IS_RSYNC_TASK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RSYNC_TASK))
#define IS_RSYNC_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RSYNC_TASK))
#define RSYNC_TASK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RSYNC_TASK, RsyncTaskClass))

typedef struct _RsyncTask RsyncTask;
typedef struct _RsyncTaskClass RsyncTaskClass;
typedef struct _RsyncTaskPrivate RsyncTaskPrivate;

#define TYPE_SYSTEM_USER (system_user_get_type ())
#define SYSTEM_USER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SYSTEM_USER, SystemUser))
#define SYSTEM_USER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SYSTEM_USER, SystemUserClass))
#define IS_SYSTEM_USER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SYSTEM_USER))
#define IS_SYSTEM_USER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SYSTEM_USER))
#define SYSTEM_USER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SYSTEM_USER, SystemUserClass))

typedef struct _SystemUser SystemUser;
typedef struct _SystemUserClass SystemUserClass;
typedef struct _SystemUserPrivate SystemUserPrivate;

#define TYPE_TIMEOUT_COUNTER (timeout_counter_get_type ())
#define TIMEOUT_COUNTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TIMEOUT_COUNTER, TimeoutCounter))
#define TIMEOUT_COUNTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TIMEOUT_COUNTER, TimeoutCounterClass))
#define IS_TIMEOUT_COUNTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TIMEOUT_COUNTER))
#define IS_TIMEOUT_COUNTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TIMEOUT_COUNTER))
#define TIMEOUT_COUNTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TIMEOUT_COUNTER, TimeoutCounterClass))

typedef struct _TimeoutCounter TimeoutCounter;
typedef struct _TimeoutCounterClass TimeoutCounterClass;
typedef struct _TimeoutCounterPrivate TimeoutCounterPrivate;

struct _AppLock {
	GObject parent_instance;
	AppLockPrivate * priv;
	gchar* lock_file;
	gchar* lock_message;
};

struct _AppLockClass {
	GObjectClass parent_class;
};

struct _AsyncTask {
	GObject parent_instance;
	AsyncTaskPrivate * priv;
	GDataOutputStream* dos_log;
	gboolean is_terminated;
	GPid child_pid;
	gchar* script_file;
	gchar* working_dir;
	gchar* log_file;
	gboolean background_mode;
	AppStatus status;
	gchar* status_line;
	gint exit_code;
	gchar* error_msg;
	GTimer* timer;
	gdouble progress;
	gdouble percent;
	gint64 prg_count;
	gint64 prg_count_total;
	gint64 prg_bytes;
	gint64 prg_bytes_total;
	gchar* eta;
};

struct _AsyncTaskClass {
	GObjectClass parent_class;
	void (*parse_stdout_line) (AsyncTask* self, const gchar* out_line);
	void (*parse_stderr_line) (AsyncTask* self, const gchar* err_line);
	void (*finish_task) (AsyncTask* self);
};

struct _CronTab {
	GObject parent_instance;
	CronTabPrivate * priv;
};

struct _CronTabClass {
	GObjectClass parent_class;
};

struct _CryptTabEntry {
	GObject parent_instance;
	CryptTabEntryPrivate * priv;
	gboolean is_comment;
	gboolean is_empty_line;
	gchar* mapped_name;
	gchar* device_string;
	gchar* keyfile;
	gchar* options;
	gchar* line;
};

struct _CryptTabEntryClass {
	GObjectClass parent_class;
};

struct _DeleteFileTask {
	AsyncTask parent_instance;
	DeleteFileTaskPrivate * priv;
	gchar* dest_path;
	gboolean verbose;
	gboolean io_nice;
	gboolean use_rsync;
	gint64 status_line_count;
	gint64 total_size;
	gchar* status_message;
	gchar* time_remaining;
};

struct _DeleteFileTaskClass {
	AsyncTaskClass parent_class;
};

struct _Device {
	GObject parent_instance;
	DevicePrivate * priv;
	gchar* device;
	gchar* name;
	gchar* kname;
	gchar* pkname;
	gchar* pkname_toplevel;
	gchar* mapped_name;
	gchar* uuid;
	gchar* label;
	gchar* partuuid;
	gchar* partlabel;
	gint major;
	gint minor;
	gchar* device_mapper;
	gchar* device_by_uuid;
	gchar* device_by_label;
	gchar* device_by_partuuid;
	gchar* device_by_partlabel;
	gchar* type;
	gchar* fstype;
	gint order;
	gchar* vendor;
	gchar* model;
	gchar* serial;
	gchar* revision;
	gboolean removable;
	gboolean read_only;
	guint64 size_bytes;
	guint64 used_bytes;
	guint64 available_bytes;
	gchar* used_percent;
	gchar* dist_info;
	GeeArrayList* mount_points;
	GeeArrayList* symlinks;
	Device* parent;
	GeeArrayList* children;
};

struct _DeviceClass {
	GObjectClass parent_class;
};

struct _FileItem {
	GObject parent_instance;
	FileItemPrivate * priv;
	gchar* file_name;
	gchar* file_location;
	gchar* file_path;
	gchar* file_path_prefix;
	GFileType file_type;
	GDateTime* modified;
	gchar* permissions;
	gchar* owner_user;
	gchar* owner_group;
	gchar* content_type;
	gchar* file_status;
	gboolean is_selected;
	gboolean is_symlink;
	gchar* symlink_target;
	glong file_count;
	glong dir_count;
	GIcon* icon;
};

struct _FileItemClass {
	GObjectClass parent_class;
};

struct _FsTabEntry {
	GObject parent_instance;
	FsTabEntryPrivate * priv;
	gboolean is_comment;
	gboolean is_empty_line;
	gchar* device_string;
	gchar* mount_point;
	gchar* type;
	gchar* options;
	gchar* dump;
	gchar* pass;
	gchar* line;
};

struct _FsTabEntryClass {
	GObjectClass parent_class;
};

struct _GracefulDBusDaemon {
	GObject parent_instance;
	GracefulDBusDaemonPrivate * priv;
};

struct _GracefulDBusDaemonClass {
	GObjectClass parent_class;
};

struct _GracefulPluginInterfaceIface {
	GTypeInterface parent_iface;
	gboolean (*activate) (GracefulPluginInterface* self);
	gboolean (*deactivate) (GracefulPluginInterface* self);
	gboolean (*is_activate) (GracefulPluginInterface* self);
	gboolean (*is_available) (GracefulPluginInterface* self);
	gchar* (*get_name) (GracefulPluginInterface* self);
	gchar* (*get_description) (GracefulPluginInterface* self);
	gchar* (*get_author) (GracefulPluginInterface* self);
	gchar* (*get_website) (GracefulPluginInterface* self);
	gchar* (*get_copyright) (GracefulPluginInterface* self);
	gchar* (*get_location) (GracefulPluginInterface* self);
};

struct _GracefulPluginManager {
	GObject parent_instance;
	GracefulPluginManagerPrivate * priv;
};

struct _GracefulPluginManagerClass {
	GObjectClass parent_class;
};

struct _IconManager {
	GObject parent_instance;
	IconManagerPrivate * priv;
};

struct _IconManagerClass {
	GObjectClass parent_class;
};

struct _LinuxDistro {
	GObject parent_instance;
	LinuxDistroPrivate * priv;
	gchar* dist_id;
	gchar* description;
	gchar* release;
	gchar* codename;
};

struct _LinuxDistroClass {
	GObjectClass parent_class;
};

struct _MountEntry {
	GObject parent_instance;
	MountEntryPrivate * priv;
	Device* device;
	gchar* mount_point;
	gchar* mount_options;
};

struct _MountEntryClass {
	GObjectClass parent_class;
};

struct _OSDNotify {
	GObject parent_instance;
	OSDNotifyPrivate * priv;
};

struct _OSDNotifyClass {
	GObjectClass parent_class;
};

struct _RsyncTask {
	AsyncTask parent_instance;
	RsyncTaskPrivate * priv;
	gboolean delete_extra;
	gboolean delete_after;
	gboolean delete_excluded;
	gboolean relative;
	gchar* rsync_log_file;
	gchar* exclude_from_file;
	gchar* link_from_path;
	gchar* source_path;
	gchar* dest_path;
	gboolean verbose;
	gboolean io_nice;
	gboolean dry_run;
	GQueue* status_lines;
	gint64 status_line_count;
	gint64 total_size;
	gint64 count_created;
	gint64 count_deleted;
	gint64 count_modified;
	gint64 count_checksum;
	gint64 count_size;
	gint64 count_timestamp;
	gint64 count_permissions;
	gint64 count_owner;
	gint64 count_group;
	gint64 count_unchanged;
	GString* log;
};

struct _RsyncTaskClass {
	AsyncTaskClass parent_class;
};

struct _SystemUser {
	GObject parent_instance;
	SystemUserPrivate * priv;
	gchar* name;
	gchar* password;
	gint uid;
	gint gid;
	gchar* user_info;
	gchar* home_path;
	gchar* shell_path;
	gchar* full_name;
	gchar* room_num;
	gchar* phone_work;
	gchar* phone_home;
	gchar* other_info;
	gchar* shadow_line;
	gchar* pwd_hash;
	gchar* pwd_last_changed;
	gchar* pwd_age_min;
	gchar* pwd_age_max;
	gchar* pwd_warning_period;
	gchar* pwd_inactivity_period;
	gchar* pwd_expiraton_date;
	gchar* reserved_field;
	gboolean has_encrypted_home;
	gboolean has_encrypted_private_dirs;
	GeeArrayList* encrypted_dirs;
	GeeArrayList* encrypted_private_dirs;
	gboolean is_selected;
};

struct _SystemUserClass {
	GObjectClass parent_class;
};

struct _TimeoutCounter {
	GObject parent_instance;
	TimeoutCounterPrivate * priv;
	gboolean active;
	gchar* process_to_kill;
	gint seconds_to_wait;
	gboolean exit_app;
};

struct _TimeoutCounterClass {
	GObjectClass parent_class;
};

GType app_lock_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (AppLock, g_object_unref)
gboolean app_lock_create (AppLock* self,
                          const gchar* app_name,
                          const gchar* message);
void app_lock_remove (AppLock* self);
AppLock* app_lock_new (void);
AppLock* app_lock_construct (GType object_type);
GType async_task_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (AsyncTask, g_object_unref)
GType app_status_get_type (void) G_GNUC_CONST ;
AsyncTask* async_task_construct (GType object_type);
gboolean async_task_begin (AsyncTask* self);
void async_task_write_stdin (AsyncTask* self,
                             const gchar* line);
void async_task_parse_stdout_line (AsyncTask* self,
                                   const gchar* out_line);
void async_task_parse_stderr_line (AsyncTask* self,
                                   const gchar* err_line);
void async_task_finish_task (AsyncTask* self);
gint async_task_read_exit_code (AsyncTask* self);
gboolean async_task_is_running (AsyncTask* self);
void async_task_pause (AsyncTask* self);
void async_task_resume (AsyncTask* self);
void async_task_stop (AsyncTask* self,
                      AppStatus status_to_update);
void async_task_set_priority (AsyncTask* self);
void async_task_set_priority_value (AsyncTask* self,
                                    gint prio);
void async_task_print_app_status (AsyncTask* self);
gchar* async_task_get_stat_time_elapsed (AsyncTask* self);
gchar* async_task_get_stat_time_remaining (AsyncTask* self);
GType cron_tab_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (CronTab, g_object_unref)
extern gchar* cron_tab_crontab_text;
void cron_tab_clear_cached_text (void);
gchar* cron_tab_crontab_read_all (const gchar* user_name);
gboolean cron_tab_has_job (const gchar* entry,
                           gboolean partial_match,
                           gboolean use_cached_text);
gboolean cron_tab_add_job (const gchar* entry,
                           gboolean use_cached_text);
gboolean cron_tab_remove_job (const gchar* entry,
                              gboolean use_regex,
                              gboolean use_cached_text);
gboolean cron_tab_install (const gchar* file_path,
                           const gchar* user_name);
gboolean cron_tab_export (const gchar* file_path,
                          const gchar* user_name);
gboolean cron_tab_import (const gchar* file_path,
                          const gchar* user_name);
gboolean cron_tab_add_script_file (const gchar* file_name,
                                   const gchar* cron_dir_type,
                                   const gchar* text,
                                   gboolean stop_cron_emails);
gboolean cron_tab_remove_script_file (const gchar* file_name,
                                      const gchar* cron_dir_type);
CronTab* cron_tab_new (void);
CronTab* cron_tab_construct (GType object_type);
GType crypt_tab_entry_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (CryptTabEntry, g_object_unref)
GeeArrayList* crypt_tab_entry_read_file (const gchar* file_path);
gchar* crypt_tab_entry_write_file (GeeArrayList* entries,
                                   const gchar* file_path,
                                   gboolean keep_comments_and_empty_lines);
void crypt_tab_entry_append_option (CryptTabEntry* self,
                                    const gchar* option);
void crypt_tab_entry_remove_option (CryptTabEntry* self,
                                    const gchar* option);
CryptTabEntry* crypt_tab_entry_find_entry_by_uuid (GeeArrayList* entries,
                                                   const gchar* uuid);
CryptTabEntry* crypt_tab_entry_new (void);
CryptTabEntry* crypt_tab_entry_construct (GType object_type);
gchar* crypt_tab_entry_get_device_uuid (CryptTabEntry* self);
void crypt_tab_entry_set_device_uuid (CryptTabEntry* self,
                                      const gchar* value);
GType delete_file_task_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (DeleteFileTask, g_object_unref)
DeleteFileTask* delete_file_task_new (void);
DeleteFileTask* delete_file_task_construct (GType object_type);
void delete_file_task_prepare (DeleteFileTask* self);
void delete_file_task_execute (DeleteFileTask* self);
gboolean delete_file_task_update_progress_parse_console_output (DeleteFileTask* self,
                                                                const gchar* line);
gint delete_file_task_read_status (DeleteFileTask* self);
GType device_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Device, g_object_unref)
GType mount_entry_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MountEntry, g_object_unref)
extern gdouble device_KB;
extern gdouble device_MB;
extern gdouble device_GB;
extern gdouble device_KiB;
extern gdouble device_MiB;
extern gdouble device_GiB;
Device* device_new (void);
Device* device_construct (GType object_type);
void device_test_lsblk_version (void);
gboolean device_is_mounted_at_path (Device* self,
                                    const gchar* subvolname,
                                    const gchar* mount_path);
gboolean device_has_linux_filesystem (Device* self);
gboolean device_is_encrypted_partition (Device* self);
gboolean device_is_on_encrypted_partition (Device* self);
gboolean device_is_lvm_partition (Device* self);
gboolean device_has_children (Device* self);
Device* device_first_linux_child (Device* self);
gboolean device_has_parent (Device* self);
GeeArrayList* device_get_filesystems (gboolean get_space,
                                      gboolean get_mounts);
GeeArrayList* device_get_block_devices_using_lsblk (const gchar* dev_name);
GeeArrayList* device_get_block_devices_using_blkid (const gchar* dev_name);
GeeArrayList* device_get_disk_space_using_df (const gchar* dev_name_or_mount_point);
GeeArrayList* device_get_mounted_filesystems_using_mtab (void);
Device* device_get_device_by_uuid (const gchar* uuid);
Device* device_get_device_by_name (const gchar* file_name);
Device* device_get_device_by_path (const gchar* path_to_check);
gchar* device_get_device_uuid (const gchar* device);
GeeArrayList* device_get_device_mount_points (const gchar* dev_name_or_uuid);
gboolean device_device_is_mounted (const gchar* dev_name_or_uuid);
gboolean device_mount_point_in_use (const gchar* mount_point);
gchar* device_resolve_device_name (const gchar* dev_alias);
Device* device_find_device_in_list (GeeArrayList* list,
                                    const gchar* _dev_alias);
void device_copy_fields_from (Device* self,
                              Device* dev2);
Device* device_query_changes (Device* self);
void device_query_disk_space (Device* self);
gboolean device_automount_udisks (const gchar* dev_name_or_uuid,
                                  GtkWindow* parent_window);
gboolean device_automount_udisks_iso (const gchar* iso_file_path,
                                      gchar* * loop_device,
                                      GtkWindow* parent_window);
gboolean device_unmount_udisks (const gchar* dev_name_or_uuid,
                                GtkWindow* parent_window);
Device* device_luks_unlock (Device* luks_device,
                            const gchar* mapped_name,
                            const gchar* passphrase,
                            GtkWindow* parent_window,
                            gchar* * message,
                            gchar* * details);
gboolean device_luks_lock (const gchar* kname,
                           GtkWindow* parent_window);
gboolean device_mount (const gchar* dev_name_or_uuid,
                       const gchar* mount_point,
                       const gchar* mount_options,
                       gboolean silent);
gchar* device_automount (const gchar* dev_name_or_uuid,
                         const gchar* mount_options,
                         const gchar* mount_prefix);
gboolean device_unmount (const gchar* mount_point);
gchar* device_description (Device* self);
gchar* device_description_formatted (Device* self);
gchar* device_description_simple (Device* self);
gchar* device_description_simple_formatted (Device* self);
gchar* device_description_full_free (Device* self);
gchar* device_description_full (Device* self);
gchar* device_description_usage (Device* self);
gchar* device_description_free (Device* self);
gchar* device_tooltip_text (Device* self);
void device_test_all (void);
void device_print_device_list (GeeArrayList* list);
void device_print_device_mounts (GeeArrayList* list);
void device_print_device_disk_space (GeeArrayList* list);
guint64 device_get_free_bytes (Device* self);
gchar* device_get_size (Device* self);
gchar* device_get_used (Device* self);
gchar* device_get_free (Device* self);
gboolean device_get_is_mounted (Device* self);
gchar* device_get_full_name_with_alias (Device* self);
gchar* device_get_full_name_with_parent (Device* self);
gchar* device_get_short_name_with_alias (Device* self);
gchar* device_get_short_name_with_parent (Device* self);
gchar* device_get_device_name_with_parent (Device* self);
GType file_item_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FileItem, g_object_unref)
FileItem* file_item_new (const gchar* name);
FileItem* file_item_construct (GType object_type,
                               const gchar* name);
FileItem* file_item_new_from_disk_path_with_basic_info (const gchar* _file_path);
FileItem* file_item_construct_from_disk_path_with_basic_info (GType object_type,
                                                              const gchar* _file_path);
FileItem* file_item_new_from_path_and_type (const gchar* _file_path,
                                            GFileType _file_type);
FileItem* file_item_construct_from_path_and_type (GType object_type,
                                                  const gchar* _file_path,
                                                  GFileType _file_type);
void file_item_query_file_info (FileItem* self);
void file_item_query_file_info_basic (FileItem* self);
GdkPixbuf* file_item_get_icon (FileItem* self,
                               gint icon_size,
                               gboolean add_transparency,
                               gboolean add_emblems);
gint64 file_item_get_size (FileItem* self);
GType fs_tab_entry_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FsTabEntry, g_object_unref)
GeeArrayList* fs_tab_entry_read_file (const gchar* file_path);
gchar* fs_tab_entry_write_file (GeeArrayList* entries,
                                const gchar* file_path,
                                gboolean keep_comments_and_empty_lines);
gchar* fs_tab_entry_subvolume_name (FsTabEntry* self);
gboolean fs_tab_entry_is_for_system_directory (FsTabEntry* self);
FsTabEntry* fs_tab_entry_find_entry_by_mount_point (GeeArrayList* entries,
                                                    const gchar* mount_path);
Device* fs_tab_entry_resolve_device (FsTabEntry* self,
                                     GeeArrayList* crypttab,
                                     GtkWindow* parent_window);
void fs_tab_entry_append_option (FsTabEntry* self,
                                 const gchar* option);
void fs_tab_entry_remove_option (FsTabEntry* self,
                                 const gchar* option);
FsTabEntry* fs_tab_entry_new (void);
FsTabEntry* fs_tab_entry_construct (GType object_type);
gchar* fs_tab_entry_get_device_uuid (FsTabEntry* self);
void fs_tab_entry_set_device_uuid (FsTabEntry* self,
                                   const gchar* value);
GType graceful_dbus_daemon_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (GracefulDBusDaemon, g_object_unref)
guint graceful_dbus_daemon_register_object (void* object,
                                            GDBusConnection* connection,
                                            const gchar* path,
                                            GError** error);
gint graceful_dbus_daemon_start (GracefulDBusDaemon* self);
gint graceful_dbus_daemon_stop (GracefulDBusDaemon* self);
GracefulDBusDaemon* graceful_dbus_daemon_new (void);
GracefulDBusDaemon* graceful_dbus_daemon_construct (GType object_type);
#define GRACEFUL_FILE_SYSTEM_KB ((gint64) 1000)
#define GRACEFUL_FILE_SYSTEM_MB (1000 * GRACEFUL_FILE_SYSTEM_KB)
#define GRACEFUL_FILE_SYSTEM_GB (1000 * GRACEFUL_FILE_SYSTEM_MB)
#define GRACEFUL_FILE_SYSTEM_TB (1000 * GRACEFUL_FILE_SYSTEM_GB)
#define GRACEFUL_FILE_SYSTEM_KiB ((gint64) 1024)
#define GRACEFUL_FILE_SYSTEM_MiB (1024 * GRACEFUL_FILE_SYSTEM_KiB)
#define GRACEFUL_FILE_SYSTEM_GiB (1024 * GRACEFUL_FILE_SYSTEM_MiB)
#define GRACEFUL_FILE_SYSTEM_TiB (1024 * GRACEFUL_FILE_SYSTEM_GiB)
gchar* graceful_file_system_file_parent (const gchar* file_path);
gchar* graceful_file_system_file_basename (const gchar* file_path);
gchar* graceful_file_system_path_combine (const gchar* path1,
                                          const gchar* path2);
gchar* graceful_file_system_remove_trailing_slash (const gchar* path);
gboolean graceful_file_system_file_or_dir_exists (const gchar* item_path);
gboolean graceful_file_system_file_exists (const gchar* file_path);
gboolean graceful_file_system_file_exists_regular (const gchar* file_path);
gboolean graceful_file_system_file_delete (const gchar* file_path);
gint64 graceful_file_system_file_line_count (const gchar* file_path);
gchar* graceful_file_system_file_read (const gchar* file_path);
gboolean graceful_file_system_file_write (const gchar* file_path,
                                          const gchar* contents);
gboolean graceful_file_system_file_copy (const gchar* src_file,
                                         const gchar* dest_file);
void graceful_file_system_file_move (const gchar* src_file,
                                     const gchar* dest_file);
gboolean graceful_file_system_file_is_symlink (const gchar* file_path);
gboolean graceful_file_system_file_gzip (const gchar* src_file);
gboolean graceful_file_system_file_gunzip (const gchar* src_file);
gchar* graceful_file_system_file_resolve_executable_path (const gchar* file_path);
gint64 graceful_file_system_file_get_size (const gchar* file_path);
GDateTime* graceful_file_system_file_get_modified_date (const gchar* file_path);
gchar* graceful_file_system_file_get_symlink_target (const gchar* file_path);
gboolean graceful_file_system_dir_exists (const gchar* dir_path);
gboolean graceful_file_system_dir_create (const gchar* dir_path,
                                          gboolean show_message);
gboolean graceful_file_system_dir_delete (const gchar* dir_path,
                                          gboolean show_message);
gboolean graceful_file_system_dir_is_empty (const gchar* dir_path);
gboolean graceful_file_system_filesystem_supports_hardlinks (const gchar* path,
                                                             gboolean* is_readonly);
GeeArrayList* graceful_file_system_dir_list_names (const gchar* path);
gboolean graceful_file_system_chown (const gchar* dir_path,
                                     const gchar* user,
                                     const gchar* group);
glong graceful_file_system_dir_count (const gchar* path);
glong graceful_file_system_dir_size (const gchar* path);
glong graceful_file_system_dir_size_kb (const gchar* path);
gchar* graceful_file_system_format_file_size (guint64 size,
                                              gboolean binary_units,
                                              const gchar* unit,
                                              gboolean show_units,
                                              gint decimals);
gchar* graceful_file_system_escape_single_quote (const gchar* file_path);
gint graceful_file_system_chmod (const gchar* file,
                                 const gchar* permission);
gint graceful_file_system_rsync (const gchar* sourceDirectory,
                                 const gchar* destDirectory,
                                 gboolean updateExisting,
                                 gboolean deleteExtra);
gchar* graceful_json_helper_json_get_string (JsonObject* jobj,
                                             const gchar* member,
                                             const gchar* def_value);
gdouble graceful_json_helper_json_get_double (JsonObject* jobj,
                                              const gchar* member,
                                              gdouble def_value);
gboolean graceful_json_helper_json_get_bool (JsonObject* jobj,
                                             const gchar* member,
                                             gboolean def_value);
gint graceful_json_helper_json_get_int (JsonObject* jobj,
                                        const gchar* member,
                                        gint def_value);
guint64 graceful_json_helper_json_get_uint64 (JsonObject* jobj,
                                              const gchar* member,
                                              guint64 def_value);
GeeArrayList* graceful_json_helper_json_get_array (JsonObject* jobj,
                                                   const gchar* member,
                                                   GeeArrayList* def_value);
extern GFileIOStream* graceful_logging_ios;
extern GDataOutputStream* graceful_logging_dos_log;
extern gchar* graceful_logging_err_log;
extern gboolean graceful_logging_LOG_ENABLE;
extern gboolean graceful_logging_LOG_TIMESTAMP;
extern gboolean graceful_logging_LOG_COLORS;
extern gboolean graceful_logging_LOG_DEBUG;
extern gboolean graceful_logging_LOG_COMMANDS;
void graceful_logging_log_init (const gchar* logDir,
                                const gchar* logFile);
void graceful_logging_log_msg (const gchar* message,
                               gboolean highlight);
void graceful_logging_log_error (const gchar* message,
                                 gboolean highlight,
                                 gboolean is_warning);
void graceful_logging_log_debug (const gchar* message);
void graceful_logging_log_to_file (const gchar* message,
                                   gboolean highlight);
void graceful_logging_log_draw_line (void);
void graceful_logging_err_log_clear (void);
void graceful_logging_err_log_disable (void);
void graceful_misc_set_numeric_locale (const gchar* type);
gchar* graceful_misc_timestamp (gboolean show_millis);
gchar* graceful_misc_timestamp_numeric (void);
gchar* graceful_misc_timestamp_for_path (void);
gchar* graceful_misc_format_date (GDateTime* date);
gchar* graceful_misc_format_date_12_hour (GDateTime* date);
gchar* graceful_misc_format_duration (glong millis);
gchar* graceful_misc_format_time_left (gint64 millis);
gdouble graceful_misc_parse_time (const gchar* time);
gchar* graceful_misc_string_replace (const gchar* str,
                                     const gchar* search,
                                     const gchar* replacement,
                                     gint count);
gchar* graceful_misc_escape_html (const gchar* html,
                                  gboolean pango_markup);
gchar* graceful_misc_unescape_html (const gchar* html);
gchar* graceful_misc_uri_encode (const gchar* path,
                                 gboolean encode_forward_slash);
gchar* graceful_misc_uri_decode (const gchar* path);
GDateTime* graceful_misc_datetime_from_string (const gchar* date_time_string);
gchar* graceful_misc_break_string_by_word (const gchar* input_text);
gchar** graceful_misc_array_concat (gchar** a,
                                    gint a_length1,
                                    gchar** b,
                                    gint b_length1,
                                    gint* result_length1);
gchar* graceful_misc_random_string (gint length,
                                    const gchar* charset);
gboolean graceful_misc_is_numeric (const gchar* text);
GType graceful_plugin_interface_get_type (void) G_GNUC_CONST ;
gboolean graceful_plugin_interface_activate (GracefulPluginInterface* self);
gboolean graceful_plugin_interface_deactivate (GracefulPluginInterface* self);
gboolean graceful_plugin_interface_is_activate (GracefulPluginInterface* self);
gboolean graceful_plugin_interface_is_available (GracefulPluginInterface* self);
gchar* graceful_plugin_interface_get_name (GracefulPluginInterface* self);
gchar* graceful_plugin_interface_get_description (GracefulPluginInterface* self);
gchar* graceful_plugin_interface_get_author (GracefulPluginInterface* self);
gchar* graceful_plugin_interface_get_website (GracefulPluginInterface* self);
gchar* graceful_plugin_interface_get_copyright (GracefulPluginInterface* self);
gchar* graceful_plugin_interface_get_location (GracefulPluginInterface* self);
GType graceful_plugin_manager_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (GracefulPluginManager, g_object_unref)
GracefulPluginManager* graceful_plugin_manager_instance (void);
GracefulPluginManager* graceful_plugin_manager_new (void);
GracefulPluginManager* graceful_plugin_manager_construct (GType object_type);
void graceful_plugin_manager_loadPlugin (GracefulPluginManager* self);
extern gchar* graceful_process_helper_TEMP_DIR;
void graceful_process_helper_init_tmp (const gchar* subdir_name);
gchar* graceful_process_helper_create_temp_subdir (void);
gint graceful_process_helper_exec_sync (const gchar* cmd,
                                        gchar* * std_out,
                                        gchar* * std_err);
gint graceful_process_helper_exec_script_sync (const gchar* script,
                                               gchar* * std_out,
                                               gchar* * std_err,
                                               gboolean supress_errors,
                                               gboolean run_as_admin,
                                               gboolean cleanup_tmp,
                                               gboolean print_to_terminal);
gint graceful_process_helper_exec_script_async (const gchar* script);
gchar* graceful_process_helper_save_bash_script_temp (const gchar* commands,
                                                      const gchar* script_path,
                                                      gboolean force_locale,
                                                      gboolean supress_errors);
gchar* graceful_process_helper_get_temp_file_path (void);
void graceful_process_helper_exec_process_new_session (const gchar* command);
gchar* graceful_process_helper_get_cmd_path (const gchar* cmd_tool);
gboolean graceful_process_helper_cmd_exists (const gchar* cmd_tool);
gint graceful_process_helper_get_pid_by_name (const gchar* name);
gint graceful_process_helper_get_pid_by_command (const gchar* cmdline);
gboolean graceful_process_helper_process_is_running (glong pid);
gboolean graceful_process_helper_process_is_running_by_name (const gchar* proc_name);
gint* graceful_process_helper_get_process_children (GPid parent_pid,
                                                    gint* result_length1);
void graceful_process_helper_process_quit (GPid process_pid,
                                           gboolean killChildren);
void graceful_process_helper_process_kill (GPid process_pid,
                                           gboolean killChildren);
gint graceful_process_helper_process_pause (GPid procID);
gint graceful_process_helper_process_resume (GPid procID);
void graceful_process_helper_process_quit_by_name (const gchar* cmd_name,
                                                   const gchar* cmd_to_match,
                                                   gboolean exact_match);
void graceful_process_helper_process_set_priority (GPid procID,
                                                   gint prio);
gint graceful_process_helper_process_get_priority (GPid procID);
void graceful_process_helper_process_set_priority_normal (GPid procID);
void graceful_process_helper_process_set_priority_low (GPid procID);
gboolean graceful_system_user_is_admin (void);
gint graceful_system_get_user_id (void);
gint graceful_system_get_user_id_effective (void);
gchar* graceful_system_get_username (void);
gchar* graceful_system_get_username_effective (void);
gint graceful_system_get_user_id_from_username (const gchar* username);
gchar* graceful_system_get_username_from_uid (gint user_id);
gchar* graceful_system_get_user_home (const gchar* username);
gchar* graceful_system_get_user_home_effective (void);
gchar* graceful_system_get_app_path (void);
gchar* graceful_system_get_app_dir (void);
gdouble graceful_system_get_system_uptime_seconds (void);
gchar* graceful_system_get_desktop_name (void);
GeeArrayList* graceful_system_list_dir_names (const gchar* path);
gboolean graceful_system_shutdown (void);
gboolean graceful_system_command_exists (const gchar* command);
gboolean graceful_system_xdg_open (const gchar* file,
                                   const gchar* user);
gboolean graceful_system_exo_open_folder (const gchar* dir_path,
                                          gboolean xdg_open_try_first);
gboolean graceful_system_exo_open_textfile (const gchar* txt_file);
gboolean graceful_system_exo_open_url (const gchar* url);
gboolean graceful_system_using_efi_boot (void);
GTimer* graceful_system_timer_start (void);
gulong graceful_system_timer_elapsed (GTimer* timer,
                                      gboolean stop);
void graceful_system_sleep (gint milliseconds);
gchar* graceful_system_timer_elapsed_string (GTimer* timer,
                                             gboolean stop);
void graceful_system_timer_elapsed_print (GTimer* timer,
                                          gboolean stop);
void graceful_system_set_numeric_locale (const gchar* type);
GType icon_manager_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IconManager, g_object_unref)
#define ICON_MANAGER_SHIELD_ICON_SIZE 64
#define ICON_MANAGER_GENERIC_ICON_IMAGE "image-x-generic"
#define ICON_MANAGER_GENERIC_ICON_IMAGE_MISSING "image-missing"
#define ICON_MANAGER_GENERIC_ICON_VIDEO "video-x-generic"
#define ICON_MANAGER_GENERIC_ICON_FILE "text-x-preview"
#define ICON_MANAGER_GENERIC_ICON_ARCHIVE_FILE "package-x-generic"
#define ICON_MANAGER_GENERIC_ICON_DIRECTORY "folder"
#define ICON_MANAGER_GENERIC_ICON_ISO "media-cdrom"
#define ICON_MANAGER_GENERIC_ICON_PDF "application-pdf"
#define ICON_MANAGER_ICON_HARDDRIVE "drive-harddisk"
#define ICON_MANAGER_SHIELD_LIVE "media-optical"
#define ICON_MANAGER_SHIELD_LOW "timeshift-shield-low"
#define ICON_MANAGER_SHIELD_MED "timeshift-shield-med"
#define ICON_MANAGER_SHIELD_HIGH "timeshift-shield-high"
extern GtkIconTheme* icon_manager_theme;
extern GeeArrayList* icon_manager_search_paths;
void icon_manager_init (gchar** args,
                        gint args_length1,
                        const gchar* app_name);
void icon_manager_refresh_icon_theme (void);
GdkPixbuf* icon_manager_lookup (const gchar* icon_name,
                                gint icon_size,
                                gboolean symbolic,
                                gboolean use_hardcoded,
                                gint scale);
GtkImage* icon_manager_lookup_image (const gchar* icon_name,
                                     gint icon_size,
                                     gboolean symbolic,
                                     gboolean use_hardcoded);
cairo_surface_t* icon_manager_lookup_surface (const gchar* icon_name,
                                              gint icon_size,
                                              gint scale,
                                              gboolean symbolic,
                                              gboolean use_hardcoded);
GdkPixbuf* icon_manager_lookup_gicon (GIcon* gicon,
                                      gint icon_size);
GtkImage* icon_manager_lookup_animation (const gchar* gif_name);
GdkPixbuf* icon_manager_add_emblem (GdkPixbuf* pixbuf,
                                    const gchar* icon_name,
                                    gint emblem_size,
                                    gboolean emblem_symbolic,
                                    GtkCornerType corner_type);
GdkPixbuf* icon_manager_add_overlay (GdkPixbuf* pixbuf_base,
                                     GdkPixbuf* pixbuf_overlay);
GdkPixbuf* icon_manager_resize_icon (GdkPixbuf* pixbuf_image,
                                     gint icon_size);
GdkPixbuf* icon_manager_add_transparency (GdkPixbuf* pixbuf,
                                          gint opacity);
GdkPixbuf* icon_manager_load_pixbuf_from_file (const gchar* file_path,
                                               gint icon_size);
IconManager* icon_manager_new (void);
IconManager* icon_manager_construct (GType object_type);
#define GPLv2LicenseText "\n" \
"                    GNU GENERAL PUBLIC LICENSE\n" \
"                       Version 2, June 1991\n" \
"\n" \
" Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n" \
" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n" \
" Everyone is permitted to copy and distribute verbatim copies\n" \
" of this license document, but changing it is not allowed.\n" \
"\n" \
"                            Preamble\n" \
"\n" \
"  The licenses for most software are designed to take away your\n" \
"freedom to share and change it.  By contrast, the GNU General Public\n" \
"License is intended to guarantee your freedom to share and change free" \
"\n" \
"software--to make sure the software is free for all its users.  This\n" \
"General Public License applies to most of the Free Software\n" \
"Foundation's software and to any other program whose authors commit to" \
"\n" \
"using it.  (Some other Free Software Foundation software is covered by" \
"\n" \
"the GNU Lesser General Public License instead.)  You can apply it to\n" \
"your programs, too.\n" \
"\n" \
"  When we speak of free software, we are referring to freedom, not\n" \
"price.  Our General Public Licenses are designed to make sure that you" \
"\n" \
"have the freedom to distribute copies of free software (and charge for" \
"\n" \
"this service if you wish), that you receive source code or can get it\n" \
"if you want it, that you can change the software or use pieces of it\n" \
"in new free programs; and that you know you can do these things.\n" \
"\n" \
"  To protect your rights, we need to make restrictions that forbid\n" \
"anyone to deny you these rights or to ask you to surrender the rights." \
"\n" \
"These restrictions translate to certain responsibilities for you if yo" \
"u\n" \
"distribute copies of the software, or if you modify it.\n" \
"\n" \
"  For example, if you distribute copies of such a program, whether\n" \
"gratis or for a fee, you must give the recipients all the rights that\n" \
"you have.  You must make sure that they, too, receive or can get the\n" \
"source code.  And you must show them these terms so they know their\n" \
"rights.\n" \
"\n" \
"  We protect your rights with two steps: (1) copyright the software, a" \
"nd\n" \
"(2) offer you this license which gives you legal permission to copy,\n" \
"distribute and/or modify the software.\n" \
"\n" \
"  Also, for each author's protection and ours, we want to make certain" \
"\n" \
"that everyone understands that there is no warranty for this free\n" \
"software.  If the software is modified by someone else and passed on, " \
"we\n" \
"want its recipients to know that what they have is not the original, s" \
"o\n" \
"that any problems introduced by others will not reflect on the origina" \
"l\n" \
"authors' reputations.\n" \
"\n" \
"  Finally, any free program is threatened constantly by software\n" \
"patents.  We wish to avoid the danger that redistributors of a free\n" \
"program will individually obtain patent licenses, in effect making the" \
"\n" \
"program proprietary.  To prevent this, we have made it clear that any\n" \
"patent must be licensed for everyone's free use or not licensed at all" \
".\n" \
"\n" \
"  The precise terms and conditions for copying, distribution and\n" \
"modification follow.\n" \
"\n" \
"                    GNU GENERAL PUBLIC LICENSE\n" \
"   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n" \
"\n" \
"  0. This License applies to any program or other work which contains\n" \
"a notice placed by the copyright holder saying it may be distributed\n" \
"under the terms of this General Public License.  The \"Program\", belo" \
"w,\n" \
"refers to any such program or work, and a \"work based on the Program\"" \
"\n" \
"means either the Program or any derivative work under copyright law:\n" \
"that is to say, a work containing the Program or a portion of it,\n" \
"either verbatim or with modifications and/or translated into another\n" \
"language.  (Hereinafter, translation is included without limitation in" \
"\n" \
"the term \"modification\".)  Each licensee is addressed as \"you\".\n" \
"\n" \
"Activities other than copying, distribution and modification are not\n" \
"covered by this License; they are outside its scope.  The act of\n" \
"running the Program is not restricted, and the output from the Program" \
"\n" \
"is covered only if its contents constitute a work based on the\n" \
"Program (independent of having been made by running the Program).\n" \
"Whether that is true depends on what the Program does.\n" \
"\n" \
"  1. You may copy and distribute verbatim copies of the Program's\n" \
"source code as you receive it, in any medium, provided that you\n" \
"conspicuously and appropriately publish on each copy an appropriate\n" \
"copyright notice and disclaimer of warranty; keep intact all the\n" \
"notices that refer to this License and to the absence of any warranty;" \
"\n" \
"and give any other recipients of the Program a copy of this License\n" \
"along with the Program.\n" \
"\n" \
"You may charge a fee for the physical act of transferring a copy, and\n" \
"you may at your option offer warranty protection in exchange for a fee" \
".\n" \
"\n" \
"  2. You may modify your copy or copies of the Program or any portion\n" \
"of it, thus forming a work based on the Program, and copy and\n" \
"distribute such modifications or work under the terms of Section 1\n" \
"above, provided that you also meet all of these conditions:\n" \
"\n" \
"    a) You must cause the modified files to carry prominent notices\n" \
"    stating that you changed the files and the date of any change.\n" \
"\n" \
"    b) You must cause any work that you distribute or publish, that in" \
"\n" \
"    whole or in part contains or is derived from the Program or any\n" \
"    part thereof, to be licensed as a whole at no charge to all third\n" \
"    parties under the terms of this License.\n" \
"\n" \
"    c) If the modified program normally reads commands interactively\n" \
"    when run, you must cause it, when started running for such\n" \
"    interactive use in the most ordinary way, to print or display an\n" \
"    announcement including an appropriate copyright notice and a\n" \
"    notice that there is no warranty (or else, saying that you provide" \
"\n" \
"    a warranty) and that users may redistribute the program under\n" \
"    these conditions, and telling the user how to view a copy of this\n" \
"    License.  (Exception: if the Program itself is interactive but\n" \
"    does not normally print such an announcement, your work based on\n" \
"    the Program is not required to print an announcement.)\n" \
"\n" \
"These requirements apply to the modified work as a whole.  If\n" \
"identifiable sections of that work are not derived from the Program,\n" \
"and can be reasonably considered independent and separate works in\n" \
"themselves, then this License, and its terms, do not apply to those\n" \
"sections when you distribute them as separate works.  But when you\n" \
"distribute the same sections as part of a whole which is a work based\n" \
"on the Program, the distribution of the whole must be on the terms of\n" \
"this License, whose permissions for other licensees extend to the\n" \
"entire whole, and thus to each and every part regardless of who wrote " \
"it.\n" \
"\n" \
"Thus, it is not the intent of this section to claim rights or contest\n" \
"your rights to work written entirely by you; rather, the intent is to\n" \
"exercise the right to control the distribution of derivative or\n" \
"collective works based on the Program.\n" \
"\n" \
"In addition, mere aggregation of another work not based on the Program" \
"\n" \
"with the Program (or with a work based on the Program) on a volume of\n" \
"a storage or distribution medium does not bring the other work under\n" \
"the scope of this License.\n" \
"\n" \
"  3. You may copy and distribute the Program (or a work based on it,\n" \
"under Section 2) in object code or executable form under the terms of\n" \
"Sections 1 and 2 above provided that you also do one of the following:" \
"\n" \
"\n" \
"    a) Accompany it with the complete corresponding machine-readable\n" \
"    source code, which must be distributed under the terms of Sections" \
"\n" \
"    1 and 2 above on a medium customarily used for software interchang" \
"e; or,\n" \
"\n" \
"    b) Accompany it with a written offer, valid for at least three\n" \
"    years, to give any third party, for a charge no more than your\n" \
"    cost of physically performing source distribution, a complete\n" \
"    machine-readable copy of the corresponding source code, to be\n" \
"    distributed under the terms of Sections 1 and 2 above on a medium\n" \
"    customarily used for software interchange; or,\n" \
"\n" \
"    c) Accompany it with the information you received as to the offer\n" \
"    to distribute corresponding source code.  (This alternative is\n" \
"    allowed only for noncommercial distribution and only if you\n" \
"    received the program in object code or executable form with such\n" \
"    an offer, in accord with Subsection b above.)\n" \
"\n" \
"The source code for a work means the preferred form of the work for\n" \
"making modifications to it.  For an executable work, complete source\n" \
"code means all the source code for all modules it contains, plus any\n" \
"associated interface definition files, plus the scripts used to\n" \
"control compilation and installation of the executable.  However, as a" \
"\n" \
"special exception, the source code distributed need not include\n" \
"anything that is normally distributed (in either source or binary\n" \
"form) with the major components (compiler, kernel, and so on) of the\n" \
"operating system on which the executable runs, unless that component\n" \
"itself accompanies the executable.\n" \
"\n" \
"If distribution of executable or object code is made by offering\n" \
"access to copy from a designated place, then offering equivalent\n" \
"access to copy the source code from the same place counts as\n" \
"distribution of the source code, even though third parties are not\n" \
"compelled to copy the source along with the object code.\n" \
"\n" \
"  4. You may not copy, modify, sublicense, or distribute the Program\n" \
"except as expressly provided under this License.  Any attempt\n" \
"otherwise to copy, modify, sublicense or distribute the Program is\n" \
"void, and will automatically terminate your rights under this License." \
"\n" \
"However, parties who have received copies, or rights, from you under\n" \
"this License will not have their licenses terminated so long as such\n" \
"parties remain in full compliance.\n" \
"\n" \
"  5. You are not required to accept this License, since you have not\n" \
"signed it.  However, nothing else grants you permission to modify or\n" \
"distribute the Program or its derivative works.  These actions are\n" \
"prohibited by law if you do not accept this License.  Therefore, by\n" \
"modifying or distributing the Program (or any work based on the\n" \
"Program), you indicate your acceptance of this License to do so, and\n" \
"all its terms and conditions for copying, distributing or modifying\n" \
"the Program or works based on it.\n" \
"\n" \
"  6. Each time you redistribute the Program (or any work based on the\n" \
"Program), the recipient automatically receives a license from the\n" \
"original licensor to copy, distribute or modify the Program subject to" \
"\n" \
"these terms and conditions.  You may not impose any further\n" \
"restrictions on the recipients' exercise of the rights granted herein." \
"\n" \
"You are not responsible for enforcing compliance by third parties to\n" \
"this License.\n" \
"\n" \
"  7. If, as a consequence of a court judgment or allegation of patent\n" \
"infringement or for any other reason (not limited to patent issues),\n" \
"conditions are imposed on you (whether by court order, agreement or\n" \
"otherwise) that contradict the conditions of this License, they do not" \
"\n" \
"excuse you from the conditions of this License.  If you cannot\n" \
"distribute so as to satisfy simultaneously your obligations under this" \
"\n" \
"License and any other pertinent obligations, then as a consequence you" \
"\n" \
"may not distribute the Program at all.  For example, if a patent\n" \
"license would not permit royalty-free redistribution of the Program by" \
"\n" \
"all those who receive copies directly or indirectly through you, then\n" \
"the only way you could satisfy both it and this License would be to\n" \
"refrain entirely from distribution of the Program.\n" \
"\n" \
"If any portion of this section is held invalid or unenforceable under\n" \
"any particular circumstance, the balance of the section is intended to" \
"\n" \
"apply and the section as a whole is intended to apply in other\n" \
"circumstances.\n" \
"\n" \
"It is not the purpose of this section to induce you to infringe any\n" \
"patents or other property right claims or to contest validity of any\n" \
"such claims; this section has the sole purpose of protecting the\n" \
"integrity of the free software distribution system, which is\n" \
"implemented by public license practices.  Many people have made\n" \
"generous contributions to the wide range of software distributed\n" \
"through that system in reliance on consistent application of that\n" \
"system; it is up to the author/donor to decide if he or she is willing" \
"\n" \
"to distribute software through any other system and a licensee cannot\n" \
"impose that choice.\n" \
"\n" \
"This section is intended to make thoroughly clear what is believed to\n" \
"be a consequence of the rest of this License.\n" \
"\n" \
"  8. If the distribution and/or use of the Program is restricted in\n" \
"certain countries either by patents or by copyrighted interfaces, the\n" \
"original copyright holder who places the Program under this License\n" \
"may add an explicit geographical distribution limitation excluding\n" \
"those countries, so that distribution is permitted only in or among\n" \
"countries not thus excluded.  In such case, this License incorporates\n" \
"the limitation as if written in the body of this License.\n" \
"\n" \
"  9. The Free Software Foundation may publish revised and/or new versi" \
"ons\n" \
"of the General Public License from time to time.  Such new versions wi" \
"ll\n" \
"be similar in spirit to the present version, but may differ in detail " \
"to\n" \
"address new problems or concerns.\n" \
"\n" \
"Each version is given a distinguishing version number.  If the Program" \
"\n" \
"specifies a version number of this License which applies to it and \"a" \
"ny\n" \
"later version\", you have the option of following the terms and condit" \
"ions\n" \
"either of that version or of any later version published by the Free\n" \
"Software Foundation.  If the Program does not specify a version number" \
" of\n" \
"this License, you may choose any version ever published by the Free So" \
"ftware\n" \
"Foundation.\n" \
"\n" \
"  10. If you wish to incorporate parts of the Program into other free\n" \
"programs whose distribution conditions are different, write to the aut" \
"hor\n" \
"to ask for permission.  For software which is copyrighted by the Free\n" \
"Software Foundation, write to the Free Software Foundation; we sometim" \
"es\n" \
"make exceptions for this.  Our decision will be guided by the two goal" \
"s\n" \
"of preserving the free status of all derivatives of our free software " \
"and\n" \
"of promoting the sharing and reuse of software generally.\n" \
"\n" \
"                            NO WARRANTY\n" \
"\n" \
"  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARR" \
"ANTY\n" \
"FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WH" \
"EN\n" \
"OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES" \
"\n" \
"PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXP" \
"RESSED\n" \
"OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n" \
"MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK" \
" AS\n" \
"TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE" \
"\n" \
"PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICIN" \
"G,\n" \
"REPAIR OR CORRECTION.\n" \
"\n" \
"  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WR" \
"ITING\n" \
"WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\n" \
"REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMA" \
"GES,\n" \
"INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES AR" \
"ISING\n" \
"OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMI" \
"TED\n" \
"TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED " \
"BY\n" \
"YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY O" \
"THER\n" \
"PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\n" \
"POSSIBILITY OF SUCH DAMAGES.\n" \
"\n" \
"                     END OF TERMS AND CONDITIONS\n" \
"\n" \
"This General Public License does not permit incorporating your program" \
" into\n" \
"proprietary programs.  If your program is a subroutine library, you ma" \
"y\n" \
"consider it more useful to permit linking proprietary applications wit" \
"h the\n" \
"library.  If this is what you want to do, use the GNU Lesser General\n" \
"Public License instead of this License.\n"
GType linux_distro_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (LinuxDistro, g_object_unref)
LinuxDistro* linux_distro_new (void);
LinuxDistro* linux_distro_construct (GType object_type);
gchar* linux_distro_full_name (LinuxDistro* self);
LinuxDistro* linux_distro_get_dist_info (const gchar* root_path);
gchar* linux_distro_get_running_desktop_name (void);
gchar* linux_distro_get_dist_type (LinuxDistro* self);
MountEntry* mount_entry_new (Device* device,
                             const gchar* mount_point,
                             const gchar* mount_options);
MountEntry* mount_entry_construct (GType object_type,
                                   Device* device,
                                   const gchar* mount_point,
                                   const gchar* mount_options);
gchar* mount_entry_subvolume_name (MountEntry* self);
gchar* mount_entry_lvm_name (MountEntry* self);
MountEntry* mount_entry_find_entry_by_mount_point (GeeArrayList* entries,
                                                   const gchar* mount_path);
GType osd_notify_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (OSDNotify, g_object_unref)
#define OSD_NOTIFY_NOTIFICATION_INTERVAL 3
gint osd_notify_notify_send (const gchar* title,
                             const gchar* message,
                             gint durationMillis,
                             const gchar* urgency,
                             const gchar* dialog_type);
gboolean osd_notify_is_supported (void);
OSDNotify* osd_notify_new (void);
OSDNotify* osd_notify_construct (GType object_type);
GType rsync_task_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (RsyncTask, g_object_unref)
RsyncTask* rsync_task_new (void);
RsyncTask* rsync_task_construct (GType object_type);
void rsync_task_prepare (RsyncTask* self);
GeeArrayList* rsync_task_parse_log (RsyncTask* self,
                                    const gchar* log_file_path);
void rsync_task_execute (RsyncTask* self);
gboolean rsync_task_update_progress_parse_console_output (RsyncTask* self,
                                                          const gchar* line);
gint rsync_task_read_status (RsyncTask* self);
GType system_user_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SystemUser, g_object_unref)
extern GeeHashMap* system_user_all_users;
SystemUser* system_user_new (const gchar* name);
SystemUser* system_user_construct (GType object_type,
                                   const gchar* name);
void system_user_query_users (gboolean no_passwords);
GeeHashMap* system_user_read_users_from_file (const gchar* passwd_file,
                                              const gchar* shadow_file,
                                              const gchar* password);
void system_user_check_encrypted_dirs (SystemUser* self);
GeeArrayList* system_user_get_all_users_sorted (void);
gboolean system_user_get_is_installed (SystemUser* self);
gboolean system_user_get_is_system (SystemUser* self);
gchar* system_user_get_group_names (SystemUser* self);
GType timeout_counter_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (TimeoutCounter, g_object_unref)
#define TIMEOUT_COUNTER_DEFAULT_SECONDS_TO_WAIT 60
void timeout_counter_kill_process_on_timeout (TimeoutCounter* self,
                                              const gchar* process_to_kill,
                                              gint seconds_to_wait,
                                              gboolean exit_app);
void timeout_counter_exit_on_timeout (TimeoutCounter* self,
                                      gint seconds_to_wait);
void timeout_counter_stop (TimeoutCounter* self);
void timeout_counter_start_counter_thread (TimeoutCounter* self);
TimeoutCounter* timeout_counter_new (void);
TimeoutCounter* timeout_counter_construct (GType object_type);

G_END_DECLS

#endif
